<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é»‘æ´é‡åŠ›æ¨¡æ“¬ - Black Hole Gravitational Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #444;
            max-width: 300px;
        }
        
        h1 {
            font-size: 20px;
            margin-bottom: 15px;
            color: #fff;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #ccc;
        }
        
        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        
        button {
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #45a049;
        }
        
        button.danger {
            background: #f44336;
        }
        
        button.danger:hover {
            background: #da190b;
        }
        
        .info {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }
        
        #stats {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #444;
            font-size: 12px;
            min-width: 200px;
        }
        
        .stat-line {
            margin-bottom: 5px;
        }
        
        #instructions {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #444;
            max-width: 280px;
            font-size: 13px;
            line-height: 1.6;
        }
        
        .instruction-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #4CAF50;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="controls">
        <h1>ğŸŒŒ é»‘æ´æ§åˆ¶é¢æ¿</h1>
        
        <div class="control-group">
            <label>ç™¼å°„é€Ÿåº¦: <span id="velocity-value">50</span></label>
            <input type="range" id="velocity" min="10" max="100" value="50">
        </div>
        
        <div class="control-group">
            <label>ç‰©é«”è³ªé‡: <span id="mass-value">5</span></label>
            <input type="range" id="mass" min="1" max="20" value="5">
        </div>
        
        <div class="control-group">
            <label>ç™¼å°„è§’åº¦: <span id="angle-value">0</span>Â°</label>
            <input type="range" id="angle" min="-90" max="90" value="0">
        </div>
        
        <button id="launch-btn">ğŸš€ ç™¼å°„ç‰©é«”</button>
        <button id="clear-btn" class="danger">ğŸ—‘ï¸ æ¸…é™¤æ‰€æœ‰ç‰©é«”</button>
        <button id="toggle-trails">âœ¨ åˆ‡æ›è»Œè·¡é¡¯ç¤º</button>
        
        <div class="info">
            é»æ“Š 3D å ´æ™¯ä¹Ÿå¯ä»¥ç™¼å°„ç‰©é«”ï¼
        </div>
    </div>
    
    <div id="instructions">
        <div class="instruction-title">æ“ä½œèªªæ˜</div>
        <div>ğŸ–±ï¸ æ‹–æ›³æ»‘é¼ ï¼šæ—‹è½‰è¦–è§’</div>
        <div>ğŸ–±ï¸ æ»¾è¼ªï¼šç¸®æ”¾è¦–é‡</div>
        <div>ğŸ–±ï¸ å³éµæ‹–æ›³ï¼šå¹³ç§»è¦–è§’</div>
        <div style="margin-top: 10px;">
            <strong>ç‰©ç†ç‰¹æ€§ï¼š</strong><br>
            â€¢ é»‘æ´è³ªé‡ï¼š10â¶ å¤ªé™½è³ªé‡<br>
            â€¢ äº‹ä»¶è¦–ç•Œï¼šç„¡æ³•é€ƒè„«çš„é‚Šç•Œ<br>
            â€¢ å¸ç©ç›¤ï¼šé«˜é€Ÿæ—‹è½‰çš„ç‰©è³ªç’°<br>
            â€¢ é‡åŠ›é€é¡ï¼šå…‰ç·šå½æ›²æ•ˆæ‡‰
        </div>
    </div>
    
    <div id="stats">
        <div class="stat-line">æ´»å‹•ç‰©é«”: <span id="object-count">0</span></div>
        <div class="stat-line">å·²åå™¬: <span id="consumed-count">0</span></div>
        <div class="stat-line">æ™‚é–“: <span id="time-elapsed">0</span>s</div>
    </div>

    <!-- å¼•å…¥ Three.js æ ¸å¿ƒåº« -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- å¼•å…¥è»Œé“æ§åˆ¶å™¨ï¼Œç”¨æ–¼ç›¸æ©Ÿäº’å‹• -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        // ============================================
        // Three.js èªªæ˜ï¼š
        // - THREE.Scene: 3D å ´æ™¯å®¹å™¨
        // - THREE.PerspectiveCamera: é€è¦–ç›¸æ©Ÿï¼Œæ¨¡æ“¬äººçœ¼è¦–è§’
        // - THREE.WebGLRenderer: WebGL æ¸²æŸ“å™¨
        // - OrbitControls: å…è¨±ç”¨æˆ¶æ—‹è½‰ã€ç¸®æ”¾å’Œå¹³ç§»ç›¸æ©Ÿ
        // ============================================
        
        // åˆå§‹åŒ–å ´æ™¯ã€ç›¸æ©Ÿå’Œæ¸²æŸ“å™¨
        let scene, camera, renderer, controls;
        let blackHole, accretionDisk, eventHorizon;
        let celestialBodies = [];
        let launchedObjects = [];
        let trails = [];
        let showTrails = true;
        
        // ç‰©ç†å¸¸æ•¸
        const G = 6.674; // é‡åŠ›å¸¸æ•¸ï¼ˆç°¡åŒ–ç‰ˆï¼‰
        const BLACK_HOLE_MASS = 1000; // é»‘æ´è³ªé‡
        const EVENT_HORIZON_RADIUS = 15; // äº‹ä»¶è¦–ç•ŒåŠå¾‘
        const TIME_SCALE = 0.016; // æ™‚é–“ç¸®æ”¾å› å­
        
        // çµ±è¨ˆæ•¸æ“š
        let objectCount = 0;
        let consumedCount = 0;
        let startTime = Date.now();
        
        function init() {
            // å‰µå»ºå ´æ™¯
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.001);
            
            // è¨­ç½®ç›¸æ©Ÿ
            camera = new THREE.PerspectiveCamera(
                75, // è¦–è§’
                window.innerWidth / window.innerHeight, // å¯¬é«˜æ¯”
                0.1, // è¿‘è£å‰ªé¢
                2000 // é è£å‰ªé¢
            );
            camera.position.set(0, 100, 200);
            camera.lookAt(0, 0, 0);
            
            // å‰µå»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // æ·»åŠ è»Œé“æ§åˆ¶å™¨
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxDistance = 500;
            controls.minDistance = 50;
            
            // æ·»åŠ ç’°å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            // æ·»åŠ é»å…‰æºï¼ˆæ¨¡æ“¬å¸ç©ç›¤ç™¼å…‰ï¼‰
            const pointLight = new THREE.PointLight(0xff6600, 2, 500);
            pointLight.position.set(0, 0, 0);
            scene.add(pointLight);
            
            // å‰µå»ºæ˜Ÿç©ºèƒŒæ™¯
            createStarField();
            
            // å‰µå»ºé»‘æ´
            createBlackHole();
            
            // å‰µå»ºè»Œé“å¤©é«”
            createOrbitalBodies();
            
            // äº‹ä»¶ç›£è½
            setupEventListeners();
            
            // é–‹å§‹å‹•ç•«å¾ªç’°
            animate();
        }
        
        // å‰µå»ºæ˜Ÿç©ºèƒŒæ™¯
        function createStarField() {
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 1,
                transparent: true,
                opacity: 0.8
            });
            
            const starsVertices = [];
            for (let i = 0; i < 10000; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                starsVertices.push(x, y, z);
            }
            
            starsGeometry.setAttribute('position', 
                new THREE.Float32BufferAttribute(starsVertices, 3));
            
            const stars = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(stars);
        }
        
        // å‰µå»ºé»‘æ´ç³»çµ±
        function createBlackHole() {
            // é»‘æ´æ ¸å¿ƒï¼ˆå®Œå…¨é»‘æš—ï¼‰
            const blackHoleGeometry = new THREE.SphereGeometry(EVENT_HORIZON_RADIUS, 32, 32);
            const blackHoleMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000,
                transparent: true,
                opacity: 1
            });
            blackHole = new THREE.Mesh(blackHoleGeometry, blackHoleMaterial);
            scene.add(blackHole);
            
            // äº‹ä»¶è¦–ç•Œå…‰ç’°
            const horizonGeometry = new THREE.SphereGeometry(EVENT_HORIZON_RADIUS + 1, 32, 32);
            const horizonMaterial = new THREE.MeshBasicMaterial({
                color: 0xff4400,
                transparent: true,
                opacity: 0.3,
                wireframe: true
            });
            eventHorizon = new THREE.Mesh(horizonGeometry, horizonMaterial);
            scene.add(eventHorizon);
            
            // å¸ç©ç›¤
            createAccretionDisk();
            
            // æ·»åŠ ç™¼å…‰æ•ˆæœ
            const glowGeometry = new THREE.SphereGeometry(EVENT_HORIZON_RADIUS * 1.5, 32, 32);
            const glowMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vNormal;
                    uniform float time;
                    void main() {
                        float intensity = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
                        vec3 glow = vec3(1.0, 0.3, 0.0) * intensity;
                        gl_FragColor = vec4(glow, intensity * 0.5);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            scene.add(glow);
            blackHole.glow = glow;
        }
        
        // å‰µå»ºå¸ç©ç›¤
        function createAccretionDisk() {
            const diskGeometry = new THREE.RingGeometry(
                EVENT_HORIZON_RADIUS * 1.5, // å…§åŠå¾‘
                EVENT_HORIZON_RADIUS * 4,   // å¤–åŠå¾‘
                64,                          // åˆ†æ®µæ•¸
                8
            );
            
            const diskMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    innerRadius: { value: EVENT_HORIZON_RADIUS * 1.5 },
                    outerRadius: { value: EVENT_HORIZON_RADIUS * 4 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    void main() {
                        vUv = uv;
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float innerRadius;
                    uniform float outerRadius;
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    
                    void main() {
                        float dist = length(vPosition.xy);
                        float normalized = (dist - innerRadius) / (outerRadius - innerRadius);
                        
                        // æ—‹è½‰æ•ˆæœ
                        float angle = atan(vPosition.y, vPosition.x);
                        float spiral = sin(angle * 8.0 + time * 2.0 - normalized * 10.0) * 0.5 + 0.5;
                        
                        // é¡è‰²æ¼¸è®Šï¼ˆå¾å…§åˆ°å¤–ï¼šç™½->æ©™->ç´…->æš—ç´…ï¼‰
                        vec3 innerColor = vec3(1.0, 0.9, 0.7);
                        vec3 midColor = vec3(1.0, 0.4, 0.1);
                        vec3 outerColor = vec3(0.5, 0.1, 0.0);
                        
                        vec3 color = mix(innerColor, midColor, normalized * 0.5);
                        color = mix(color, outerColor, normalized * 0.5 + 0.5);
                        
                        // æ·»åŠ èºæ—‹ç´‹ç†
                        color *= spiral * 0.3 + 0.7;
                        
                        // é€æ˜åº¦éš¨è·é›¢è®ŠåŒ–
                        float alpha = (1.0 - normalized) * 0.7;
                        
                        gl_FragColor = vec4(color, alpha);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
            
            accretionDisk = new THREE.Mesh(diskGeometry, diskMaterial);
            accretionDisk.rotation.x = Math.PI / 2;
            scene.add(accretionDisk);
        }
        
        // å‰µå»ºè»Œé“å¤©é«”
        function createOrbitalBodies() {
            const bodyConfigs = [
                { distance: 80, velocity: 0.8, size: 3, color: 0x4444ff, mass: 5 },
                { distance: 120, velocity: 0.6, size: 4, color: 0xff4444, mass: 8 },
                { distance: 160, velocity: 0.5, size: 2.5, color: 0x44ff44, mass: 4 },
                { distance: 200, velocity: 0.4, size: 3.5, color: 0xffff44, mass: 6 },
            ];
            
            bodyConfigs.forEach(config => {
                const geometry = new THREE.SphereGeometry(config.size, 16, 16);
                const material = new THREE.MeshStandardMaterial({
                    color: config.color,
                    emissive: config.color,
                    emissiveIntensity: 0.3,
                    metalness: 0.5,
                    roughness: 0.5
                });
                
                const body = new THREE.Mesh(geometry, material);
                
                // éš¨æ©Ÿèµ·å§‹è§’åº¦
                const angle = Math.random() * Math.PI * 2;
                body.position.x = Math.cos(angle) * config.distance;
                body.position.z = Math.sin(angle) * config.distance;
                body.position.y = (Math.random() - 0.5) * 10;
                
                // è¨ˆç®—åˆå§‹é€Ÿåº¦ï¼ˆå‚ç›´æ–¼åŠå¾‘æ–¹å‘ï¼‰
                const speed = config.velocity;
                body.velocity = new THREE.Vector3(
                    -Math.sin(angle) * speed,
                    0,
                    Math.cos(angle) * speed
                );
                
                body.mass = config.mass;
                body.trail = [];
                
                scene.add(body);
                celestialBodies.push(body);
            });
        }
        
        // ç™¼å°„ç‰©é«”
        function launchObject(velocity, mass, angle) {
            const geometry = new THREE.SphereGeometry(mass * 0.5, 16, 16);
            const material = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                emissive: 0x888888,
                emissiveIntensity: 0.5
            });
            
            const obj = new THREE.Mesh(geometry, material);
            
            // å¾ç›¸æ©Ÿæ–¹å‘ç™¼å°„
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);
            
            // è¨­ç½®èµ·å§‹ä½ç½®ï¼ˆè·é›¢é»‘æ´è¼ƒé ï¼‰
            obj.position.copy(camera.position).add(cameraDirection.multiplyScalar(30));
            
            // è¨ˆç®—ç™¼å°„æ–¹å‘ï¼ˆåŠ å…¥è§’åº¦èª¿æ•´ï¼‰
            const angleRad = angle * Math.PI / 180;
            const right = new THREE.Vector3();
            right.crossVectors(camera.up, cameraDirection).normalize();
            
            const direction = cameraDirection.clone();
            direction.applyAxisAngle(right, angleRad).normalize();
            
            obj.velocity = direction.multiplyScalar(velocity * 0.5);
            obj.mass = mass;
            obj.trail = [];
            obj.isLaunched = true;
            
            scene.add(obj);
            launchedObjects.push(obj);
            objectCount++;
            
            updateStats();
        }
        
        // è¨ˆç®—é‡åŠ›
        function applyGravity(body) {
            const distance = body.position.length();
            
            // å¦‚æœé€²å…¥äº‹ä»¶è¦–ç•Œï¼Œæ¨™è¨˜ç‚ºè¢«åå™¬
            if (distance < EVENT_HORIZON_RADIUS) {
                body.consumed = true;
                return;
            }
            
            // è¨ˆç®—é‡åŠ›åŠ é€Ÿåº¦: a = GM/rÂ²
            const forceMagnitude = (G * BLACK_HOLE_MASS * body.mass) / (distance * distance);
            
            // é‡åŠ›æ–¹å‘æŒ‡å‘é»‘æ´ä¸­å¿ƒ
            const forceDirection = body.position.clone().normalize().multiplyScalar(-1);
            
            // åŠ é€Ÿåº¦ = åŠ› / è³ªé‡
            const acceleration = forceDirection.multiplyScalar(forceMagnitude / body.mass);
            
            // æ›´æ–°é€Ÿåº¦
            body.velocity.add(acceleration.multiplyScalar(TIME_SCALE));
            
            // é™åˆ¶æœ€å¤§é€Ÿåº¦ï¼ˆé¿å…æ•¸å€¼çˆ†ç‚¸ï¼‰
            const maxSpeed = 20;
            if (body.velocity.length() > maxSpeed) {
                body.velocity.normalize().multiplyScalar(maxSpeed);
            }
        }
        
        // æ›´æ–°ç‰©é«”ä½ç½®
        function updateBodies() {
            // æ›´æ–°å¤©é«”
            celestialBodies.forEach(body => {
                applyGravity(body);
                body.position.add(body.velocity.clone().multiplyScalar(TIME_SCALE));
                
                // è¨˜éŒ„è»Œè·¡
                if (showTrails && body.trail.length < 100) {
                    body.trail.push(body.position.clone());
                }
            });
            
            // æ›´æ–°ç™¼å°„ç‰©é«”
            for (let i = launchedObjects.length - 1; i >= 0; i--) {
                const body = launchedObjects[i];
                
                applyGravity(body);
                body.position.add(body.velocity.clone().multiplyScalar(TIME_SCALE));
                
                // è¨˜éŒ„è»Œè·¡
                if (showTrails && body.trail.length < 200) {
                    body.trail.push(body.position.clone());
                }
                
                // ç§»é™¤è¢«åå™¬æˆ–é£›å¤ªé çš„ç‰©é«”
                if (body.consumed) {
                    scene.remove(body);
                    launchedObjects.splice(i, 1);
                    consumedCount++;
                    objectCount--;
                    
                    // å‰µå»ºåå™¬ç‰¹æ•ˆ
                    createConsumptionEffect(body.position.clone());
                } else if (body.position.length() > 800) {
                    scene.remove(body);
                    launchedObjects.splice(i, 1);
                    objectCount--;
                }
            }
            
            updateStats();
        }
        
        // å‰µå»ºåå™¬ç‰¹æ•ˆ
        function createConsumptionEffect(position) {
            const particleCount = 50;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            
            for (let i = 0; i < particleCount; i++) {
                positions.push(
                    position.x + (Math.random() - 0.5) * 10,
                    position.y + (Math.random() - 0.5) * 10,
                    position.z + (Math.random() - 0.5) * 10
                );
                colors.push(1, Math.random() * 0.5, 0);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                transparent: true,
                opacity: 1
            });
            
            const particles = new THREE.Points(geometry, material);
            scene.add(particles);
            
            // æ·¡å‡ºå‹•ç•«
            let opacity = 1;
            const fadeOut = setInterval(() => {
                opacity -= 0.05;
                material.opacity = opacity;
                if (opacity <= 0) {
                    scene.remove(particles);
                    clearInterval(fadeOut);
                }
            }, 50);
        }
        
        // ç¹ªè£½è»Œè·¡
        function drawTrails() {
            // æ¸…é™¤èˆŠè»Œè·¡
            trails.forEach(trail => scene.remove(trail));
            trails = [];
            
            if (!showTrails) return;
            
            // ç¹ªè£½å¤©é«”è»Œè·¡
            celestialBodies.forEach(body => {
                if (body.trail.length > 1) {
                    const points = body.trail.map(p => new THREE.Vector3(p.x, p.y, p.z));
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const material = new THREE.LineBasicMaterial({
                        color: body.material.color,
                        transparent: true,
                        opacity: 0.3
                    });
                    const line = new THREE.Line(geometry, material);
                    scene.add(line);
                    trails.push(line);
                }
            });
            
            // ç¹ªè£½ç™¼å°„ç‰©é«”è»Œè·¡
            launchedObjects.forEach(body => {
                if (body.trail.length > 1) {
                    const points = body.trail.map(p => new THREE.Vector3(p.x, p.y, p.z));
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const material = new THREE.LineBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.5
                    });
                    const line = new THREE.Line(geometry, material);
                    scene.add(line);
                    trails.push(line);
                }
            });
        }
        
        // æ›´æ–°çµ±è¨ˆ
        function updateStats() {
            document.getElementById('object-count').textContent = objectCount;
            document.getElementById('consumed-count').textContent = consumedCount;
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            document.getElementById('time-elapsed').textContent = elapsed;
        }
        
        // è¨­ç½®äº‹ä»¶ç›£è½
        function setupEventListeners() {
            // ç™¼å°„æŒ‰éˆ•
            document.getElementById('launch-btn').addEventListener('click', () => {
                const velocity = parseFloat(document.getElementById('velocity').value);
                const mass = parseFloat(document.getElementById('mass').value);
                const angle = parseFloat(document.getElementById('angle').value);
                launchObject(velocity, mass, angle);
            });
            
            // æ¸…é™¤æŒ‰éˆ•
            document.getElementById('clear-btn').addEventListener('click', () => {
                launchedObjects.forEach(obj => scene.remove(obj));
                launchedObjects = [];
                objectCount = 0;
                consumedCount = 0;
                updateStats();
            });
            
            // åˆ‡æ›è»Œè·¡
            document.getElementById('toggle-trails').addEventListener('click', () => {
                showTrails = !showTrails;
                if (!showTrails) {
                    celestialBodies.forEach(body => body.trail = []);
                    launchedObjects.forEach(body => body.trail = []);
                }
            });
            
            // æ»‘æ¡¿æ•¸å€¼é¡¯ç¤º
            document.getElementById('velocity').addEventListener('input', (e) => {
                document.getElementById('velocity-value').textContent = e.target.value;
            });
            
            document.getElementById('mass').addEventListener('input', (e) => {
                document.getElementById('mass-value').textContent = e.target.value;
            });
            
            document.getElementById('angle').addEventListener('input', (e) => {
                document.getElementById('angle-value').textContent = e.target.value;
            });
            
            // é»æ“Šå ´æ™¯ç™¼å°„
            renderer.domElement.addEventListener('click', (event) => {
                const velocity = parseFloat(document.getElementById('velocity').value);
                const mass = parseFloat(document.getElementById('mass').value);
                const angle = parseFloat(document.getElementById('angle').value);
                launchObject(velocity, mass, angle);
            });
            
            // è¦–çª—å¤§å°èª¿æ•´
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        // å‹•ç•«å¾ªç’°
        function animate() {
            requestAnimationFrame(animate);
            
            // æ›´æ–°æ§åˆ¶å™¨
            controls.update();
            
            // æ›´æ–°ç‰©ç†
            updateBodies();
            
            // æ—‹è½‰æ•ˆæœ
            if (eventHorizon) {
                eventHorizon.rotation.y += 0.005;
            }
            
            if (accretionDisk) {
                accretionDisk.rotation.z += 0.01;
                accretionDisk.material.uniforms.time.value += 0.016;
            }
            
            if (blackHole && blackHole.glow) {
                blackHole.glow.material.uniforms.time.value += 0.016;
            }
            
            // æ›´æ–°è»Œè·¡
            drawTrails();
            
            // æ¸²æŸ“å ´æ™¯
            renderer.render(scene, camera);
        }
        
        // åˆå§‹åŒ–æ‡‰ç”¨
        init();
    </script>
</body>
</html>

