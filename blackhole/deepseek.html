<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Black Hole Gravitational Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #000;
            color: white;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            max-width: 300px;
            z-index: 100;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        button {
            background: #4a4a9c;
            color: white;
            border: none;
            padding: 8px 12px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background: #5a5aac;
        }
        #launch-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="info">
            <h3>Black Hole Simulation</h3>
            <p>This simulation demonstrates gravitational effects around a Schwarzschild black hole.</p>
            <p>Click and drag to rotate the view. Use mouse wheel to zoom.</p>
        </div>
        <div id="controls">
            <button id="launch-btn">Launch Object</button>
            <button id="reset-btn">Reset Simulation</button>
            <div>
                <label for="speed-slider">Launch Speed: </label>
                <input type="range" id="speed-slider" min="0.1" max="2" step="0.1" value="1">
                <span id="speed-value">1.0</span>
            </div>
        </div>
        <div id="launch-info">
            <p>Objects launched: <span id="launch-count">0</span></p>
            <p>Objects captured: <span id="capture-count">0</span></p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    
    <script>
        // Main simulation code
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize Three.js scene
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000011);
            document.getElementById('container').appendChild(renderer.domElement);

            // Add orbit controls
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Set camera position
            camera.position.set(0, 20, 30);
            controls.update();

            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0x333333);
            scene.add(ambientLight);

            // Add directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 7);
            scene.add(directionalLight);

            // Create black hole
            const blackHoleGeometry = new THREE.SphereGeometry(2, 32, 32);
            const blackHoleMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x000000,
                transparent: true,
                opacity: 0.9
            });
            const blackHole = new THREE.Mesh(blackHoleGeometry, blackHoleMaterial);
            scene.add(blackHole);

            // Add gravitational lensing effect (simplified)
            const lensingGeometry = new THREE.RingGeometry(2.2, 3, 64);
            const lensingMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x4444ff, 
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.3
            });
            const lensing = new THREE.Mesh(lensingGeometry, lensingMaterial);
            lensing.rotation.x = Math.PI / 2;
            scene.add(lensing);

            // Create accretion disk
            const accretionDiskGeometry = new THREE.RingGeometry(3, 8, 64);
            const accretionDiskMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff4400, 
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.7
            });
            const accretionDisk = new THREE.Mesh(accretionDiskGeometry, accretionDiskMaterial);
            accretionDisk.rotation.x = Math.PI / 2;
            scene.add(accretionDisk);

            // Add stars in the background
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 1000;
            const starPositions = new Float32Array(starCount * 3);
            
            for (let i = 0; i < starCount * 3; i++) {
                starPositions[i] = (Math.random() - 0.5) * 200;
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.5,
                transparent: true
            });
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);

            // Celestial bodies array
            const celestialBodies = [];
            const launchedObjects = [];
            
            // Create initial celestial bodies
            function createCelestialBody(radius, color, distance, speed) {
                const geometry = new THREE.SphereGeometry(radius, 16, 16);
                const material = new THREE.MeshPhongMaterial({ color });
                const body = new THREE.Mesh(geometry, material);
                
                // Set initial position
                const angle = Math.random() * Math.PI * 2;
                body.position.x = Math.cos(angle) * distance;
                body.position.z = Math.sin(angle) * distance;
                
                // Set velocity for orbit
                body.velocity = new THREE.Vector3(
                    Math.sin(angle) * speed,
                    0,
                    -Math.cos(angle) * speed
                );
                
                body.userData = {
                    distance: distance,
                    speed: speed,
                    captured: false
                };
                
                scene.add(body);
                celestialBodies.push(body);
                return body;
            }

            // Create initial orbiting bodies
            createCelestialBody(0.5, 0x4488ff, 10, 0.8);
            createCelestialBody(0.7, 0x44ff88, 15, 0.6);
            createCelestialBody(0.6, 0xff8844, 20, 0.5);
            createCelestialBody(0.4, 0x8844ff, 25, 0.4);

            // Launch an object toward the black hole
            function launchObject() {
                const launchSpeed = parseFloat(document.getElementById('speed-slider').value);
                
                const geometry = new THREE.SphereGeometry(0.3, 16, 16);
                const material = new THREE.MeshPhongMaterial({ color: 0xffff00 });
                const object = new THREE.Mesh(geometry, material);
                
                // Start from a position away from the black hole
                object.position.set(0, 0, -30);
                
                // Set velocity toward the black hole with some randomness
                const randomOffset = (Math.random() - 0.5) * 0.5;
                object.velocity = new THREE.Vector3(
                    randomOffset,
                    0,
                    launchSpeed
                );
                
                object.userData = {
                    type: 'launched',
                    captured: false
                };
                
                scene.add(object);
                launchedObjects.push(object);
                
                // Update launch count
                const launchCount = document.getElementById('launch-count');
                launchCount.textContent = parseInt(launchCount.textContent) + 1;
            }

            // Reset simulation
            function resetSimulation() {
                // Remove launched objects
                launchedObjects.forEach(obj => {
                    scene.remove(obj);
                });
                launchedObjects.length = 0;
                
                // Reset celestial bodies
                celestialBodies.forEach(body => {
                    const angle = Math.random() * Math.PI * 2;
                    body.position.x = Math.cos(angle) * body.userData.distance;
                    body.position.z = Math.sin(angle) * body.userData.distance;
                    
                    body.velocity.set(
                        Math.sin(angle) * body.userData.speed,
                        0,
                        -Math.cos(angle) * body.userData.speed
                    );
                    
                    body.userData.captured = false;
                });
                
                // Reset counters
                document.getElementById('launch-count').textContent = '0';
                document.getElementById('capture-count').textContent = '0';
            }

            // Update speed display
            document.getElementById('speed-slider').addEventListener('input', function() {
                document.getElementById('speed-value').textContent = this.value;
            });

            // Set up event listeners
            document.getElementById('launch-btn').addEventListener('click', launchObject);
            document.getElementById('reset-btn').addEventListener('click', resetSimulation);

            // Animation and physics update
            function animate() {
                requestAnimationFrame(animate);
                
                // Update controls
                controls.update();
                
                // Rotate accretion disk
                accretionDisk.rotation.z += 0.01;
                
                // Update celestial bodies
                celestialBodies.forEach(body => {
                    if (body.userData.captured) return;
                    
                    // Calculate direction to black hole
                    const direction = new THREE.Vector3()
                        .subVectors(blackHole.position, body.position)
                        .normalize();
                    
                    // Calculate distance to black hole
                    const distance = body.position.distanceTo(blackHole.position);
                    
                    // Apply gravitational force (inverse square law)
                    const gravityStrength = 10; // Gravitational constant for our simulation
                    const force = gravityStrength / (distance * distance);
                    
                    // Update velocity
                    body.velocity.add(direction.multiplyScalar(force * 0.1));
                    
                    // Update position
                    body.position.add(body.velocity);
                    
                    // Check if captured by black hole
                    if (distance < 3) {
                        body.userData.captured = true;
                        body.material.color.set(0x222222);
                    }
                });
                
                // Update launched objects
                let captureCount = 0;
                launchedObjects.forEach((object, index) => {
                    if (object.userData.captured) {
                        captureCount++;
                        return;
                    }
                    
                    // Calculate direction to black hole
                    const direction = new THREE.Vector3()
                        .subVectors(blackHole.position, object.position)
                        .normalize();
                    
                    // Calculate distance to black hole
                    const distance = object.position.distanceTo(blackHole.position);
                    
                    // Apply gravitational force
                    const gravityStrength = 10;
                    const force = gravityStrength / (distance * distance);
                    
                    // Update velocity
                    object.velocity.add(direction.multiplyScalar(force * 0.1));
                    
                    // Update position
                    object.position.add(object.velocity);
                    
                    // Check if captured by black hole
                    if (distance < 3) {
                        object.userData.captured = true;
                        object.material.color.set(0x222222);
                        captureCount++;
                    }
                    
                    // Remove if too far
                    if (distance > 100) {
                        scene.remove(object);
                        launchedObjects.splice(index, 1);
                    }
                });
                
                // Update capture count
                document.getElementById('capture-count').textContent = captureCount;
                
                // Render the scene
                renderer.render(scene, camera);
            }

            // Handle window resize
            window.addEventListener('resize', function() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // Start animation
            animate();
        });
    </script>
</body>
</html>