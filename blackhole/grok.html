<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Interactive Relativistic Black Hole Simulator</title>
  <style>
    body { margin:0; overflow:hidden; background:#000; }
    #info { position:absolute; top:10px; left:10px; color:white; font-family:Arial; background:rgba(0,0,0,0.5); padding:10px; border-radius:5px; }
    #instructions { position:absolute; bottom:10px; left:10px; color:#aaa; font-family:Arial; background:rgba(0,0,0,0.7); padding:10px; border-radius:5px; }
  </style>
</head>
<body>
<div id="info">Relativistic Black Hole Simulator<br>Scroll to zoom • Drag to rotate • Click+drag to launch particle</div>
<div id="instructions">Red orbit = stable • Yellow = critically bound • White = plunging</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/controls/OrbitControls.js';

let scene, camera, renderer, controls;
let blackHole, accretionDisk;
let particles = [];
let clock = new THREE.Clock();

init();
animate();

function init() {
  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 10, 30);

  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  document.body.appendChild(renderer.domElement);

  controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;

  // === Black Hole (Event Horizon + Photon Sphere Glow) ===
  const bhGeometry = new THREE.SphereGeometry(1, 64, 64);
  const bhMaterial = new THREE.MeshBasicMaterial({color: 0x000000});
  blackHole = new THREE.Mesh(bhGeometry, bhMaterial);
  scene.add(blackHole);

  // Photon sphere glow (1.5 Rs)
  const glowGeometry = new THREE.SphereGeometry(1.5, 64, 64);
  const glowMaterial = new THREE.MeshBasicMaterial({
    color: 0xffaa00,
    transparent: true,
    opacity: 0.15,
    side: THREE.BackSide
  });
  const glow = new THREE.Mesh(glowGeometry, glowMaterial);
  scene.add(glow);

  // === Accretion Disk (shader with relativistic effects) ===
  const diskGeometry = new THREE.RingGeometry(2.5, 25, 128, 32);
  const diskMaterial = new THREE.ShaderMaterial({
    uniforms: {
      time: { value: 0 },
      innerRadius: { value: 2.5 },
      photonRadius: { value: 1.5 }
    },
    vertexShader: `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform float time;
      uniform float innerRadius;
      uniform float photonRadius;
      varying vec2 vUv;
      
      float dopplerFactor(vec2 pos, float phi) {
        float r = length(pos);
        float beta = 0.6 * sqrt(photonRadius / max(r, photonRadius)); // orbital velocity approximation
        float cosPhi = -pos.x / r; // viewing angle
        return sqrt(1.0 - beta*beta) / (1.0 - beta * cosPhi);
      }
      
      void main() {
        vec2 center = vec2(0.5, 0.5);
        vec2 pos = (vUv - center) * 50.0;
        float r = length(pos);
        if (r < innerRadius) discard;
        
        float phi = atan(pos.y, pos.x) + time * 0.2;
        float brightness = pow(dopplerFactor(pos, phi), 3.0);
        brightness *= exp(-0.03 * (r - innerRadius)); // falloff
        
        vec3 hot = vec3(1.0, 0.7, 0.3);
        vec3 cold = vec3(0.3, 0.5, 1.0);
        vec3 color = mix(cold, hot, pow(brightness, 0.5));
        
        gl_FragColor = vec4(color * brightness * 3.0, 0.95);
      }
    `,
    side: THREE.DoubleSide,
    transparent: true,
    blending: THREE.AdditiveBlending
  });
  accretionDisk = new THREE.Mesh(diskGeometry, diskMaterial);
  accretionDisk.rotation.x = -Math.PI / 2;
  scene.add(accretionDisk);

  // === Pre-existing test particles (stable, critical, plunging) ===
  createOrbitingParticle(5.0, 0xe74c3c, 500);  // stable red
  createOrbitingParticle(3.0, 0xf1c40f, 300);  // critical yellow
  createOrbitingParticle(2.0, 0xffffff, 200);  // plunging white

  // Stars background
  const starsGeometry = new THREE.BufferGeometry();
  const starsVertices = [];
  for (let i = 0; i < 10000; i++) {
    const x = THREE.MathUtils.randFloatSpread(500);
    const y = THREE.MathUtils.randFloatSpread(500);
    const z = THREE.MathUtils.randFloatSpread(500);
    starsVertices.push(x, y, z);
  }
  starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
  const starsMaterial = new THREE.PointsMaterial({color: 0xffffff, size: 0.7});
  const starField = new THREE.Points(starsGeometry, starsMaterial);
  scene.add(starField);

  // Mouse launch handling
  let isMouseDown = false;
  let mouse = new THREE.Vector2();
  let launchStart = new THREE.Vector2();

  renderer.domElement.addEventListener('pointerdown', (e) => {
    isMouseDown = true;
    launchStart.set(e.clientX, e.clientY);
  });
  renderer.domElement.addEventListener('pointerup', (e) => {
    if (!isMouseDown) return;
    isMouseDown = false;
    const dx = (e.clientX - launchStart.x) / window.innerWidth;
    const dy = (e.clientY - launchStart.y) / window.innerHeight;
    launchParticle(dx * 30, -dy * 30); // velocity proportional to drag
  });

  window.addEventListener('resize', onWindowResize);
}

function createOrbitingParticle(initialR, color, lifetime) {
  const geometry = new THREE.SphereGeometry(0.15, 16, 16);
  const material = new THREE.MeshBasicMaterial({color});
  const mesh = new THREE.Mesh(geometry, material);
  scene.add(mesh);

  // Initial conditions (circular or near-circular orbits in Schwarzschild)
  const r = initialR;
  const phi = Math.random() * Math.PI * 2;
  const omega = Math.sqrt(1 / (r * r * r)) * (1 + 3 / (r * r)); // approximate relativistic correction
  const state = {
    r: r,
    phi: phi,
    drdt: 0,
    dphidt: omega * 1.1, // slight eccentricity for visual interest
    mesh: mesh,
    trail: new THREE.BufferGeometry(),
    trailPositions: [],
    maxTrail: 300,
    lifetime: lifetime
  };
  particles.push(state);
}

function launchParticle(vx, vz) {
  const geometry = new THREE.SphereGeometry(0.2, 16, 16);
  const material = new THREE.MeshBasicMaterial({color: 0x00ff00});
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.set(20, 0, 0); // start far away
  scene.add(mesh);

  const state = {
    r: 20,
    phi: 0,
    drdt: -5, // initial radial velocity toward BH
    dphidt: (vz / 20) * 1.5, // angular momentum from vertical drag
    mesh: mesh,
    trail: new THREE.BufferGeometry(),
    trailPositions: [],
    maxTrail: 500,
    lifetime: 1000,
    isUserLaunched: true
  };
  particles.push(state);
}

// Effective potential geodesic integration (Schwarzschild metric, timelike)
function updateParticle(p, dt) {
  if (p.r <= 1.01) { // swallowed
    scene.remove(p.mesh);
    return false;
  }

  const r = Math.max(p.r, 1.01);
  const L = r * r * p.dphidt; // specific angular momentum
  const E2 = (1 - 2/r) * (1 + L*L/(r*r)); // energy from effective potential
  const V = (1 - 2/r) * (1 + L*L/(r*r));

  // Radial acceleration (geodesic equation approximation)
  const drdt_new = p.drdt - dt * (3 * L * L / (r * r * r * r)); // ISCO correction term
  const dphidt_new = L / (r * r);

  p.r += p.drdt * dt;
  p.phi += p.dphidt * dt;
  p.drdt = drdt_new;
  p.dphidt = dphidt_new;

  // Cartesian position
  p.mesh.position.set(p.r * Math.cos(p.phi), 0, p.r * Math.sin(p.phi));

  // Trail
  p.trailPositions.push(p.mesh.position.x, p.mesh.position.y, p.mesh.position.z);
  if (p.trailPositions.length > p.maxTrail * 3) {
    p.trailPositions.splice(0, 3);
  }
  p.trail.setAttribute('position', new THREE.Float32BufferAttribute(p.trailPositions, 3));
  if (!p.trailLine) {
    const lineMat = new THREE.LineBasicMaterial({color: p.mesh.material.color, opacity: 0.6, transparent: true});
    p.trailLine = new THREE.Line(p.trail, lineMat);
    scene.add(p.trailLine);
  } else {
    p.trailLine.geometry.setAttribute('position', new THREE.Float32BufferAttribute(p.trailPositions, 3));
  }

  return true;
}

function animate() {
  requestAnimationFrame(animate);
  const delta = clock.getDelta();

  controls.update();
  accretionDisk.material.uniforms.time.value += delta;

  // Update all particles
  for (let i = particles.length - 1; i >= 0; i--) {
    if (!updateParticle(particles[i], delta * 10)) { // time scaling
      particles.splice(i, 1);
    }
  }

  renderer.render(scene, camera);
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}
</script>
</body>
</html>