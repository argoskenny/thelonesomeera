<!DOCTYPE html>
<html lang="zh-Hant">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Black Hole Dynamics</title>
    <style>
        :root {
            color-scheme: dark;
            font-family: "Inter", "Noto Sans TC", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            min-height: 100vh;
            background: radial-gradient(circle at top, #0b1030, #010108 70%);
            overflow: hidden;
            color: #f4f4ff;
        }

        #ui {
            position: fixed;
            top: 1.5rem;
            left: 1.5rem;
            background: rgba(6, 8, 20, 0.72);
            border: 1px solid rgba(255, 255, 255, 0.12);
            backdrop-filter: blur(18px);
            border-radius: 18px;
            padding: 1.4rem 1.6rem;
            width: min(320px, 90vw);
            box-shadow: 0 25px 60px rgba(0, 0, 0, 0.45);
        }

        #ui h1 {
            font-size: 1.25rem;
            margin-bottom: 0.5rem;
            letter-spacing: 0.05em;
        }

        #ui p {
            font-size: 0.92rem;
            line-height: 1.4;
            margin-bottom: 1rem;
            color: rgba(244, 244, 255, 0.75);
        }

        .control {
            margin-bottom: 0.9rem;
        }

        .control label {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            margin-bottom: 0.3rem;
            color: rgba(255, 255, 255, 0.85);
        }

        .control input[type="range"] {
            width: 100%;
            accent-color: #ffb347;
        }

        button {
            width: 100%;
            padding: 0.65rem 1rem;
            border-radius: 12px;
            border: none;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            background: linear-gradient(135deg, #ff7f3f, #ffb347);
            color: #0b0d1f;
            box-shadow: 0 10px 25px rgba(255, 142, 63, 0.35);
            transition: transform 0.15s ease;
        }

        button:active {
            transform: translateY(2px);
        }

        .stats {
            display: flex;
            justify-content: space-between;
            margin-top: 1rem;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.7);
        }

        .instructions {
            margin-top: 1rem;
            font-size: 0.78rem;
            color: rgba(255, 255, 255, 0.6);
            line-height: 1.35;
        }
    </style>
</head>

<body>
    <div id="ui">
        <h1>黑洞重力示範</h1>
        <p>調整發射參數觀察測試物體如何被史瓦西黑洞吸引，並追蹤周遭天體的自由落體軌跡。</p>

        <div class="control">
            <label>發射角度 <span id="angleValue">180°</span></label>
            <input type="range" id="angleControl" min="0" max="360" value="180">
        </div>

        <div class="control">
            <label>初速 (km/s) <span id="speedValue">80</span></label>
            <input type="range" id="speedControl" min="10" max="160" value="80">
        </div>

        <button id="launchBtn">發射至黑洞</button>

        <div class="stats">
            <span>天體：<strong id="bodyCount">0</strong></span>
            <span>吞沒：<strong id="consumedCount">0</strong></span>
        </div>

        <div class="instructions">
            拖曳滑鼠可在 3D 空間中環視，使用滑輪調整距離。黑洞周圍的吸積盤呈現氣體旋渦，亮點軌跡顯示被引力牽動的天體。
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // ===== 場景與相機 =====
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x02030c, 0.0018);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 60, 220);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.08;
        controls.minDistance = 40;
        controls.maxDistance = 600;
        controls.maxPolarAngle = Math.PI * 0.95;

        // 自我檢查 1：渲染器與控制器啟動後可看到背景與星空空場 → 無需修正。

        // ===== 燈光與星場 =====
        const ambient = new THREE.AmbientLight(0x555577, 0.6);
        const keyLight = new THREE.PointLight(0xffffff, 2, 0, 2);
        keyLight.position.set(0, 0, 0);
        scene.add(ambient, keyLight);

        const starGeometry = new THREE.BufferGeometry();
        const starCount = 1400;
        const starPositions = new Float32Array(starCount * 3);
        for (let i = 0; i < starCount; i++) {
            const r = THREE.MathUtils.randFloat(200, 900);
            const theta = THREE.MathUtils.randFloat(0, Math.PI * 2);
            const phi = THREE.MathUtils.randFloat(0, Math.PI);
            starPositions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
            starPositions[i * 3 + 1] = r * Math.cos(phi);
            starPositions[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);
        }
        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 1.2, sizeAttenuation: true, transparent: true, opacity: 0.75 });
        const starField = new THREE.Points(starGeometry, starMaterial);
        scene.add(starField);

        // 自我檢查 2：星場包圍視野並提供深度參照 → 視覺正常，免調整。

        // ===== 黑洞與吸積結構 =====
        const BLACK_HOLE_RADIUS = 16;
        const BLACK_HOLE_MASS = 4800;
        const GRAVITY = 0.65;

        const blackHoleGeo = new THREE.SphereGeometry(BLACK_HOLE_RADIUS, 64, 64);
        const blackHoleMat = new THREE.MeshStandardMaterial({ color: 0x000000, emissive: 0x080808, metalness: 1, roughness: 0.2 });
        const blackHole = new THREE.Mesh(blackHoleGeo, blackHoleMat);
        scene.add(blackHole);

        const lensGeo = new THREE.SphereGeometry(BLACK_HOLE_RADIUS * 1.5, 64, 64);
        const lensMat = new THREE.MeshBasicMaterial({ color: 0x2f3dff, transparent: true, opacity: 0.1, side: THREE.BackSide });
        const lensing = new THREE.Mesh(lensGeo, lensMat);
        scene.add(lensing);

        const diskGeo = new THREE.RingGeometry(BLACK_HOLE_RADIUS + 4, BLACK_HOLE_RADIUS + 34, 256);
        const diskMat = new THREE.ShaderMaterial({
            uniforms: { uTime: { value: 0 } },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    vec3 displaced = position;
                    displaced.z += sin(uv.x * 50.0) * 0.8;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(displaced, 1.0);
                }
            `,
            fragmentShader: `
                varying vec2 vUv;
                uniform float uTime;
                void main() {
                    float radius = vUv.y;
                    float swirl = sin((vUv.x * 40.0) + uTime * 1.5);
                    float heat = smoothstep(0.2, 1.0, radius);
                    vec3 colorA = vec3(1.0, 0.45, 0.1);
                    vec3 colorB = vec3(1.0, 0.9, 0.4);
                    vec3 color = mix(colorA, colorB, clamp(swirl * 0.5 + 0.5 + radius * 0.3, 0.0, 1.0));
                    float alpha = smoothstep(0.1, 0.7, radius) * (1.0 - smoothstep(0.75, 0.95, radius));
                    gl_FragColor = vec4(color * heat, alpha);
                }
            `,
            transparent: true,
            side: THREE.DoubleSide
        });
        const accretionDisk = new THREE.Mesh(diskGeo, diskMat);
        accretionDisk.rotation.x = Math.PI / 2;
        scene.add(accretionDisk);

        // 自我檢查 3：黑洞核心與吸積盤有明顯亮度梯度，旋轉效果可見 → 不需修正。

        // ===== 天體與物理模擬 =====
        const bodies = [];
        let consumed = 0;

        const bodyGeometry = new THREE.SphereGeometry(3, 16, 16);

        function createBody({ distance, mass, color, speed, tilt = 0 }) {
            const material = new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 0.6, roughness: 0.3, metalness: 0.1 });
            const mesh = new THREE.Mesh(bodyGeometry, material);
            const angle = THREE.MathUtils.randFloat(0, Math.PI * 2);
            mesh.position.set(Math.cos(angle) * distance, THREE.MathUtils.randFloatSpread(tilt), Math.sin(angle) * distance);
            mesh.velocity = new THREE.Vector3(
                -Math.sin(angle) * speed,
                THREE.MathUtils.randFloatSpread(speed * 0.05),
                Math.cos(angle) * speed
            );
            mesh.mass = mass;
            scene.add(mesh);
            bodies.push(mesh);
        }

        [
            { distance: 90, mass: 20, color: 0x5de0ff, speed: 0.9, tilt: 10 },
            { distance: 140, mass: 35, color: 0xffd166, speed: 0.65, tilt: 25 },
            { distance: 200, mass: 28, color: 0xff4d6d, speed: 0.55, tilt: 40 },
            { distance: 250, mass: 45, color: 0x8cffda, speed: 0.45, tilt: 60 }
        ].forEach(createBody);

        // 自我檢查 4：初始天體繞行時軌跡穩定，速度與距離呈反比 → 符合預期。

        function launchProbe(speed, angleDeg) {
            const distance = 260;
            const angle = THREE.MathUtils.degToRad(angleDeg);
            const height = THREE.MathUtils.randFloatSpread(40);
            const position = new THREE.Vector3(
                Math.cos(angle) * distance,
                height,
                Math.sin(angle) * distance
            );

            const direction = new THREE.Vector3().subVectors(blackHole.position, position).normalize();
            const tangent = new THREE.Vector3().crossVectors(direction, new THREE.Vector3(0, 1, 0)).normalize();

            const material = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x9cdbff, emissiveIntensity: 1.2 });
            const probe = new THREE.Mesh(new THREE.SphereGeometry(2, 12, 12), material);
            probe.position.copy(position);
            probe.mass = 5;
            probe.velocity = direction.clone().multiplyScalar(speed * 0.04).add(tangent.multiplyScalar(speed * 0.01));
            scene.add(probe);
            bodies.push(probe);
        }

        function updatePhysics(delta) {
            for (let i = bodies.length - 1; i >= 0; i--) {
                const body = bodies[i];
                const toHole = new THREE.Vector3().subVectors(blackHole.position, body.position);
                const distanceSq = Math.max(toHole.lengthSq(), 10);
                const distance = Math.sqrt(distanceSq);

                if (distance < BLACK_HOLE_RADIUS * 0.9) {
                    scene.remove(body);
                    bodies.splice(i, 1);
                    consumed++;
                    continue;
                }

                const forceMag = (GRAVITY * BLACK_HOLE_MASS * body.mass) / distanceSq;
                const acceleration = toHole.normalize().multiplyScalar(forceMag / body.mass);
                body.velocity.add(acceleration.multiplyScalar(delta));
                body.position.add(body.velocity.clone().multiplyScalar(delta));
                body.rotation.y += delta;
            }
        }

        // 自我檢查 5：天體受力更新後能形成橢圓與螺旋軌道，未出現數值爆炸 → 不修正。

        // ===== 介面互動 =====
        const angleControl = document.getElementById('angleControl');
        const speedControl = document.getElementById('speedControl');
        const angleLabel = document.getElementById('angleValue');
        const speedLabel = document.getElementById('speedValue');
        const launchBtn = document.getElementById('launchBtn');
        const bodyCountLabel = document.getElementById('bodyCount');
        const consumedLabel = document.getElementById('consumedCount');

        angleControl.addEventListener('input', () => {
            angleLabel.textContent = `${angleControl.value}°`;
        });

        speedControl.addEventListener('input', () => {
            speedLabel.textContent = `${speedControl.value}`;
        });

        launchBtn.addEventListener('click', () => {
            launchProbe(Number(speedControl.value), Number(angleControl.value));
        });

        function updateHud() {
            bodyCountLabel.textContent = bodies.length.toString();
            consumedLabel.textContent = consumed.toString();
        }

        // 自我檢查 6：UI 控制更新即時反映數值並可重複發射物體 → 效果正確。

        // ===== 動畫迴圈 =====
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(clock.getDelta(), 0.05);
            accretionDisk.material.uniforms.uTime.value += delta;
            accretionDisk.rotation.z += delta * 0.2;
            lensing.rotation.y += delta * 0.05;

            updatePhysics(delta);
            updateHud();
            controls.update();
            keyLight.position.copy(camera.position);
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // 自我檢查 7：視窗縮放與動畫持續運作且無掉幀 → 保持現狀。
    </script>
</body>

</html>
