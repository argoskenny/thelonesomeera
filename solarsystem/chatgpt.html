<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D Solar System — Single Page</title>
  <style>
    :root {
      --bg: #0c0f14;
      --panel: #111722aa;
      --text: #e6eefb;
      --muted: #9fb4d0;
      --accent: #6ea8fe;
    }
    * { box-sizing: border-box; }
    html, body { margin: 0; height: 100%; background: var(--bg); color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"; }
    #scene { position: fixed; inset: 0; }

    /* Overlay UI */
    .hud { position: fixed; top: 12px; left: 12px; padding: 12px 14px; background: var(--panel); backdrop-filter: blur(8px); border: 1px solid #1f2733; border-radius: 14px; box-shadow: 0 10px 30px rgba(0,0,0,.35); display: grid; gap: 10px; width: min(380px, calc(100vw - 24px)); }
    .hud h1 { font-size: 16px; margin: 0 0 4px 0; letter-spacing: 0.3px; color: var(--muted); font-weight: 600; }
    .row { display: grid; grid-template-columns: 120px 1fr; align-items: center; gap: 10px; }
    .row label { font-size: 12px; color: var(--muted); }
    .row input[type="range"] { width: 100%; }
    .row select, .row button { width: 100%; padding: 8px 10px; border-radius: 10px; border: 1px solid #223047; background: #111827; color: var(--text); }
    .toggle { display: flex; align-items: center; gap: 8px; }
    .footer { font-size: 12px; color: var(--muted); display: flex; gap: 10px; align-items: center; }
    .footer .dot { width: 6px; height: 6px; border-radius: 50%; background: var(--accent); display: inline-block; }
    .badge { padding: 3px 8px; border: 1px solid #20324a; border-radius: 999px; font-size: 11px; color: #bcd3f0; }

    /* Small helper toast (top-right) */
    .toast { position: fixed; top: 12px; right: 12px; padding: 8px 12px; background: var(--panel); border: 1px solid #1f2733; border-radius: 10px; color: var(--muted); font-size: 12px; }

    @media (max-width: 560px){ .row { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <div id="scene" aria-label="Three.js canvas container"></div>

  <div class="hud" role="group" aria-label="Simulation controls">
    <div style="display:flex; justify-content:space-between; align-items:center;">
      <h1>Solar System</h1>
      <span class="badge">Three.js</span>
    </div>
    <div class="row">
      <label for="speed">Speed (days/sec)</label>
      <input id="speed" type="range" min="0" max="200" step="1" value="30" />
    </div>
    <div class="row">
      <label for="focus">Focus</label>
      <select id="focus"></select>
    </div>
    <div class="row">
      <label>Playback</label>
      <div style="display:flex; gap:8px;">
        <button id="pauseBtn" aria-pressed="false">⏸ Pause</button>
        <button id="resumeBtn" disabled>▶ Resume</button>
      </div>
    </div>
    <div class="row">
      <label>Options</label>
      <div class="toggle">
        <input type="checkbox" id="orbitsToggle" checked />
        <label for="orbitsToggle">Show orbit rings</label>
      </div>
    </div>
    <div class="footer"><span class="dot"></span> Drag to rotate · Scroll to zoom · Right-drag to pan</div>
  </div>

  <div class="toast" id="toast" hidden>Ready.</div>

  <!-- External libs (ES modules) -->
  <script type="module">
    // External library: Three.js
    // Purpose: 3D rendering (scenes, camera, lights, meshes)
    // Required inputs: a canvas container to append renderer; device pixel ratio; animation loop callback
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    // External helper: OrbitControls from Three.js examples
    // Purpose: mouse interaction to orbit/zoom/pan around a target
    // Required inputs: camera instance, DOM element to listen on (renderer.domElement)
    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';

    // ---------- DOM ----------
    const container = document.getElementById('scene');
    const speedSlider = document.getElementById('speed');
    const focusSelect = document.getElementById('focus');
    const pauseBtn = document.getElementById('pauseBtn');
    const resumeBtn = document.getElementById('resumeBtn');
    const orbitsToggle = document.getElementById('orbitsToggle');
    const toast = document.getElementById('toast');

    // ---------- Core Three setup ----------
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x05070b);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 5000);
    camera.position.set(0, 80, 280);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    container.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 20; // prevent going through objects
    controls.maxDistance = 1500;

    // ---------- Lights ----------
    const ambient = new THREE.AmbientLight(0x3b4a5a, 0.5);
    scene.add(ambient);

    const sunLight = new THREE.PointLight(0xfff3ad, 2.5, 0, 2); // strong light at the sun
    scene.add(sunLight);

    // ---------- Starfield ----------
    function makeStarfield(count = 2000, spread = 1500){
      const geo = new THREE.BufferGeometry();
      const positions = new Float32Array(count * 3);
      for(let i = 0; i < count; i++){
        positions[i*3 + 0] = (Math.random() * 2 - 1) * spread;
        positions[i*3 + 1] = (Math.random() * 2 - 1) * spread * 0.6; // flatter band for subtle disc
        positions[i*3 + 2] = (Math.random() * 2 - 1) * spread;
      }
      geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const mat = new THREE.PointsMaterial({ size: 1.4, transparent: true, opacity: 0.85 });
      const stars = new THREE.Points(geo, mat);
      scene.add(stars);
    }
    makeStarfield();

    // ---------- Sun ----------
    const sunGroup = new THREE.Group();
    scene.add(sunGroup);

    const sunRadius = 6.0; // visually compressed
    const sunGeo = new THREE.SphereGeometry(sunRadius, 64, 64);
    const sunMat = new THREE.MeshStandardMaterial({ color: 0xffd966, emissive: 0xffc94c, emissiveIntensity: 1.6, metalness: 0.0, roughness: 0.35 });
    const sunMesh = new THREE.Mesh(sunGeo, sunMat);
    sunMesh.castShadow = false; sunMesh.receiveShadow = false;
    sunGroup.add(sunMesh);
    sunLight.position.copy(sunMesh.position);

    // ---------- Planet data (scaled) ----------
    // Sizes relative to Earth (compressed), distances in AU * distanceScale
    const distanceScale = 12; // AU to world units
    const radiusScale = 0.45; // Earth ~ 0.45 units

    const PLANETS = [
      { name: 'Mercury', color: 0xc9c9c9, radiusEarths: 0.383, distanceAU: 0.39, orbitDays: 88,    rotationHours: 1407.6 },
      { name: 'Venus',   color: 0xe5c07b, radiusEarths: 0.949, distanceAU: 0.72, orbitDays: 224.7, rotationHours: -5832.5 }, // retrograde rotation
      { name: 'Earth',   color: 0x6ea8fe, radiusEarths: 1.0,   distanceAU: 1.00, orbitDays: 365.25,rotationHours: 23.93 },
      { name: 'Moon',    color: 0xdddddd, radiusEarths: 0.273, distanceAU: 0.00257, orbitDays: 27.3, rotationHours: 655.7, isMoon: true, parent: 'Earth' },
      { name: 'Mars',    color: 0xd06959, radiusEarths: 0.532, distanceAU: 1.52, orbitDays: 687,   rotationHours: 24.62 },
      { name: 'Jupiter', color: 0xd8b38a, radiusEarths: 11.21, distanceAU: 5.20, orbitDays: 4331, rotationHours: 9.93 },
      { name: 'Saturn',  color: 0xf0d9a4, radiusEarths: 9.45,  distanceAU: 9.58, orbitDays: 10747, rotationHours: 10.7, hasRings: true },
      { name: 'Uranus',  color: 0x9ed5f5, radiusEarths: 4.01,  distanceAU: 19.22,orbitDays: 30687, rotationHours: -17.24 }, // retrograde-ish (tilt 98°)
      { name: 'Neptune', color: 0x5ab0ff, radiusEarths: 3.88,  distanceAU: 30.05,orbitDays: 60190, rotationHours: 16.11 },
    ];

    // Build objects
    const solar = { sun: sunMesh, orbitsVisible: true, groups: {}, meshes: {}, orbitLines: {} };

    // Helper to make an orbit ring as a dashed line
    function makeOrbit(radius){
      const segments = 256;
      const curve = new THREE.EllipseCurve(0,0, radius, radius);
      const points = curve.getPoints(segments);
      const geo = new THREE.BufferGeometry().setFromPoints(points);
      const mat = new THREE.LineDashedMaterial({ color: 0x345, dashSize: 2, gapSize: 1, linewidth: 1 });
      const line = new THREE.LineLoop(geo, mat);
      line.computeLineDistances();
      line.userData.isOrbit = true;
      return line;
    }

    // Create planet groups (for revolution) and meshes
    const planetOrder = [];
    const planetByName = {};

    PLANETS.forEach(p => {
      if(p.isMoon) return; // moons later after parent exists
      const group = new THREE.Group();
      scene.add(group);
      solar.groups[p.name] = group;

      const orbitRadius = p.distanceAU * distanceScale;
      const ring = makeOrbit(orbitRadius);
      scene.add(ring);
      solar.orbitLines[p.name] = ring;

      const radius = Math.max(0.2, p.radiusEarths * radiusScale);
      const geo = new THREE.SphereGeometry(radius, 48, 48);
      const mat = new THREE.MeshStandardMaterial({ color: p.color, roughness: 0.6, metalness: 0.0 });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.x = orbitRadius;
      mesh.castShadow = false; mesh.receiveShadow = false;
      group.add(mesh);
      solar.meshes[p.name] = mesh;
      planetOrder.push(p.name);
      planetByName[p.name] = p;

      // Saturn ring
      if(p.hasRings){
        const ringGeo = new THREE.RingGeometry(radius*1.3, radius*2.2, 64);
        const ringMat = new THREE.MeshStandardMaterial({ color: 0xbda37a, side: THREE.DoubleSide, roughness: 0.7, metalness: 0.0, transparent: true, opacity: 0.9 });
        const ringMesh = new THREE.Mesh(ringGeo, ringMat);
        ringMesh.rotation.x = Math.PI / 2.2;
        mesh.add(ringMesh);
      }
    });

    // Add Moon around Earth
    const earthMesh = solar.meshes['Earth'];
    if(earthMesh){
      const moonSpec = PLANETS.find(p => p.name === 'Moon');
      const moonGroup = new THREE.Group();
      if(moonSpec){
        earthMesh.add(moonGroup);
        const moonOrbitRadius = moonSpec.distanceAU * distanceScale * 100; // scale up since AU is huge
        const moonRing = makeOrbit(moonOrbitRadius);
        moonRing.position.copy(earthMesh.position); // visual alignment (parented ring is tricky); keep simple by adding to scene but we'll skip for moon to reduce clutter

        const moonRadius = Math.max(0.12, moonSpec.radiusEarths * radiusScale);
        const moonGeo = new THREE.SphereGeometry(moonRadius, 32, 32);
        const moonMat = new THREE.MeshStandardMaterial({ color: moonSpec.color, roughness: 0.8 });
        const moonMesh = new THREE.Mesh(moonGeo, moonMat);
        moonMesh.position.x = moonOrbitRadius;
        moonGroup.add(moonMesh);

        solar.groups['Moon'] = moonGroup;
        solar.meshes['Moon'] = moonMesh;
        planetOrder.splice(planetOrder.indexOf('Earth') + 1, 0, 'Moon');
        planetByName['Moon'] = moonSpec;
      }
    }

    // ---------- UI population ----------
    const focusOptions = ['Sun', ...planetOrder];
    focusOptions.forEach(name => {
      const opt = document.createElement('option');
      opt.value = name; opt.textContent = name;
      focusSelect.appendChild(opt);
    });

    // ---------- Animation state ----------
    let paused = false;
    let timeScaleDaysPerSec = parseFloat(speedSlider.value); // days per real second
    let lastT = performance.now();

    function setToast(msg){ toast.textContent = msg; toast.hidden = false; clearTimeout(setToast.t); setToast.t = setTimeout(()=> toast.hidden = true, 1200); }

    // Focus helper (smooth camera reposition)
    function focusOn(name){
      let target = new THREE.Vector3();
      let distance = 80;
      if(name === 'Sun'){
        target.set(0,0,0); distance = 220;
      } else {
        const mesh = solar.meshes[name];
        if(mesh){
          mesh.updateWorldMatrix(true, false);
          target.setFromMatrixPosition(mesh.matrixWorld);
          const radius = mesh.geometry.parameters.radius || 1;
          distance = 12 + Math.max(40, radius * 40);
        }
      }
      // Move controls target and camera smoothly
      const from = controls.target.clone();
      const to = target.clone();
      const camDir = new THREE.Vector3().subVectors(camera.position, from);
      const newCamPos = to.clone().add(camDir.setLength(distance));

      let t = 0; const dur = 0.6; // seconds
      function tween(){
        if(t >= 1){ controls.target.copy(to); camera.position.copy(newCamPos); return; }
        t += 0.016 / dur; // approx 60fps
        controls.target.lerpVectors(from, to, t);
        camera.position.lerpVectors(camera.position, newCamPos, t);
        requestAnimationFrame(tween);
      }
      tween();
      setToast(`Focus: ${name}`);
    }

    focusSelect.addEventListener('change', e => focusOn(e.target.value));

    // UI events
    speedSlider.addEventListener('input', e => {
      timeScaleDaysPerSec = parseFloat(e.target.value);
      setToast(`Speed: ${timeScaleDaysPerSec} days/sec`);
    });

    pauseBtn.addEventListener('click', () => { paused = true; pauseBtn.disabled = true; resumeBtn.disabled = false; pauseBtn.setAttribute('aria-pressed', 'true'); setToast('Paused'); });
    resumeBtn.addEventListener('click', () => { paused = false; resumeBtn.disabled = true; pauseBtn.disabled = false; pauseBtn.setAttribute('aria-pressed', 'false'); setToast('Resumed'); });

    orbitsToggle.addEventListener('change', () => {
      solar.orbitsVisible = orbitsToggle.checked;
      Object.values(solar.orbitLines).forEach(line => line.visible = solar.orbitsVisible);
      setToast(solar.orbitsVisible ? 'Orbits shown' : 'Orbits hidden');
    });

    // ---------- Simulation step ----------
    function step(now){
      const dtSec = Math.min(0.05, (now - lastT) / 1000); // clamp big tabs
      lastT = now;
      controls.update();

      if(!paused){
        const dDays = dtSec * timeScaleDaysPerSec;
        // Spin the sun slowly for fun
        sunMesh.rotation.y += 0.02 * dDays;

        // Revolutions & rotations
        Object.keys(solar.meshes).forEach(name => {
          if(name === 'Moon') return; // handled below
          const mesh = solar.meshes[name];
          const spec = planetByName[name];
          if(!spec) return;

          // revolution via rotating its group around Y
          const group = solar.groups[name];
          if(group && spec.orbitDays){
            const angleInc = (dDays / spec.orbitDays) * Math.PI * 2;
            group.rotation.y += angleInc;
          }

          // axial rotation
          if(spec.rotationHours){
            const rotDays = spec.rotationHours / 24; // days per spin (may be negative)
            mesh.rotation.y += (dDays / rotDays) * Math.PI * 2;
          }
        });

        // Moon around Earth
        const moon = solar.meshes['Moon'];
        const moonSpec = planetByName['Moon'];
        const moonGroup = solar.groups['Moon'];
        if(moon && moonSpec && moonGroup){
          const angleInc = (dDays / moonSpec.orbitDays) * Math.PI * 2;
          moonGroup.rotation.y += angleInc;
          // synchronous-like rotation (approx)
          const rotDays = moonSpec.rotationHours / 24;
          moon.rotation.y += (dDays / rotDays) * Math.PI * 2;
        }
      }

      renderer.render(scene, camera);
      requestAnimationFrame(step);
    }
    requestAnimationFrame((t)=>{ lastT = t; step(t); });

    // ---------- Resize handling ----------
    function onResize(){
      const w = window.innerWidth, h = window.innerHeight;
      camera.aspect = w / h; camera.updateProjectionMatrix();
      renderer.setSize(w, h, false);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    }
    window.addEventListener('resize', onResize);

    // Initial focus and visibility states
    focusOn('Sun');
    Object.values(solar.orbitLines).forEach(line => line.visible = solar.orbitsVisible);
  </script>
</body>
</html>
